<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GeoRef ‚Äî Raster Georeferencing Tool</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.3/dist-browser/geotiff.js"></script>
<style>
  :root {
    --bg-primary: #0f1117;
    --bg-secondary: #181b24;
    --bg-tertiary: #1e2230;
    --bg-elevated: #252a38;
    --border: #2d3348;
    --border-focus: #c9915a;
    --text-primary: #e8e6e1;
    --text-secondary: #9a9ba3;
    --text-muted: #5f6170;
    --accent: #c9915a;
    --accent-dim: #a07240;
    --accent-glow: rgba(201,145,90,0.15);
    --success: #5cb07e;
    --error: #d45d5d;
    --warning: #d4a94d;
    --info: #5a8ec9;
    --gcp-color-1: #ff6b6b;
    --gcp-color-2: #4ecdc4;
    --gcp-color-3: #ffe66d;
    --gcp-color-4: #a78bfa;
    --gcp-color-5: #f97316;
    --gcp-color-6: #22d3ee;
    --gcp-color-7: #34d399;
    --gcp-color-8: #f472b6;
    --radius: 8px;
    --radius-lg: 12px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 28px;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .logo-icon {
    width: 36px;
    height: 36px;
    border-radius: var(--radius);
    background: linear-gradient(135deg, var(--accent), var(--accent-dim));
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 700;
    color: var(--bg-primary);
  }

  .logo h1 {
    font-size: 20px;
    font-weight: 600;
    letter-spacing: -0.3px;
  }

  .logo h1 span {
    color: var(--accent);
  }

  .logo-subtitle {
    font-size: 11px;
    color: var(--text-muted);
    letter-spacing: 1.5px;
    text-transform: uppercase;
    margin-top: 1px;
  }

  .header-actions {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  /* ‚îÄ‚îÄ Buttons ‚îÄ‚îÄ */
  .btn {
    display: inline-flex;
    align-items: center;
    gap: 7px;
    padding: 8px 16px;
    border-radius: var(--radius);
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    border: 1px solid var(--border);
    background: var(--bg-elevated);
    color: var(--text-primary);
    transition: all 0.2s;
  }

  .btn:hover { border-color: var(--text-muted); background: var(--bg-tertiary); }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }

  .btn-primary {
    background: var(--accent);
    border-color: var(--accent);
    color: var(--bg-primary);
    font-weight: 600;
  }

  .btn-primary:hover { background: var(--accent-dim); border-color: var(--accent-dim); }

  .btn-sm { padding: 5px 10px; font-size: 12px; }

  .btn-danger {
    color: var(--error);
    border-color: transparent;
    background: transparent;
  }

  .btn-danger:hover { background: rgba(212,93,93,0.1); border-color: var(--error); }

  /* ‚îÄ‚îÄ Layout ‚îÄ‚îÄ */
  .app-layout {
    display: grid;
    grid-template-columns: 1fr 380px;
    height: calc(100vh - 65px);
  }

  /* ‚îÄ‚îÄ Canvas Panel ‚îÄ‚îÄ */
  .canvas-panel {
    position: relative;
    overflow: hidden;
    background: var(--bg-primary);
    border-right: 1px solid var(--border);
  }

  .canvas-toolbar {
    position: absolute;
    top: 14px;
    left: 14px;
    z-index: 20;
    display: flex;
    gap: 6px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 4px;
  }

  .canvas-toolbar .btn {
    border: none;
    background: transparent;
    padding: 7px 10px;
    border-radius: 6px;
    font-size: 16px;
    min-width: 36px;
    justify-content: center;
  }

  .canvas-toolbar .btn:hover { background: var(--bg-elevated); }
  .canvas-toolbar .btn.active { background: var(--accent); color: var(--bg-primary); }

  .canvas-info {
    position: absolute;
    bottom: 14px;
    left: 14px;
    z-index: 20;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 8px 14px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text-secondary);
    display: flex;
    gap: 16px;
  }

  .canvas-info span { color: var(--text-muted); }

  #imageCanvas {
    cursor: crosshair;
    display: block;
  }

  /* ‚îÄ‚îÄ Upload overlay ‚îÄ‚îÄ */
  .upload-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    background: var(--bg-primary);
    transition: opacity 0.3s;
  }

  .upload-overlay.hidden { opacity: 0; pointer-events: none; }

  .upload-zone {
    width: 460px;
    max-width: 90%;
    padding: 60px 40px;
    border: 2px dashed var(--border);
    border-radius: var(--radius-lg);
    text-align: center;
    cursor: pointer;
    transition: all 0.3s;
  }

  .upload-zone:hover, .upload-zone.dragover {
    border-color: var(--accent);
    background: var(--accent-glow);
  }

  .upload-icon {
    font-size: 48px;
    margin-bottom: 18px;
    opacity: 0.8;
  }

  .upload-zone h3 {
    font-size: 17px;
    font-weight: 500;
    margin-bottom: 8px;
  }

  .upload-zone p {
    font-size: 13px;
    color: var(--text-secondary);
    line-height: 1.6;
  }

  .upload-zone .formats {
    margin-top: 16px;
    display: flex;
    gap: 6px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .format-tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    padding: 3px 8px;
    background: var(--bg-tertiary);
    border-radius: 4px;
    color: var(--text-muted);
    text-transform: uppercase;
  }

  /* ‚îÄ‚îÄ Side Panel ‚îÄ‚îÄ */
  .side-panel {
    display: flex;
    flex-direction: column;
    background: var(--bg-secondary);
    overflow: hidden;
  }

  .panel-tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    background: var(--bg-tertiary);
  }

  .panel-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-muted);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.8px;
  }

  .panel-tab:hover { color: var(--text-secondary); }
  .panel-tab.active { color: var(--accent); border-bottom-color: var(--accent); }

  .panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 0;
  }

  .tab-page { display: none; }
  .tab-page.active { display: block; }

  /* ‚îÄ‚îÄ GCP Section ‚îÄ‚îÄ */
  .section-header {
    padding: 16px 20px 10px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .section-header h3 {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .gcp-instructions {
    padding: 0 20px 14px;
    font-size: 12px;
    color: var(--text-muted);
    line-height: 1.6;
  }

  .gcp-list {
    padding: 0 12px;
  }

  .gcp-card {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 8px;
    overflow: hidden;
    transition: border-color 0.2s;
  }

  .gcp-card:hover { border-color: var(--text-muted); }
  .gcp-card.incomplete { border-left: 3px solid var(--warning); }
  .gcp-card.complete { border-left: 3px solid var(--success); }

  .gcp-card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
  }

  .gcp-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    font-weight: 600;
  }

  .gcp-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .gcp-card-body {
    padding: 0 12px 12px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }

  .gcp-field {
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .gcp-field label {
    font-size: 10px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .gcp-field input {
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 6px 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-primary);
    width: 100%;
    transition: border-color 0.2s;
  }

  .gcp-field input:focus {
    outline: none;
    border-color: var(--accent);
  }

  .gcp-field input:read-only {
    color: var(--text-muted);
    background: var(--bg-secondary);
  }

  .gcp-empty {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-muted);
    font-size: 13px;
  }

  .gcp-empty .icon { font-size: 32px; margin-bottom: 10px; opacity: 0.5; }

  /* ‚îÄ‚îÄ Settings ‚îÄ‚îÄ */
  .settings-section {
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }

  .settings-section h4 {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .setting-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
  }

  .setting-row label {
    font-size: 13px;
    color: var(--text-primary);
  }

  select, .setting-input {
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 6px 10px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-primary);
    width: 180px;
    cursor: pointer;
  }

  select:focus, .setting-input:focus {
    outline: none;
    border-color: var(--accent);
  }

  /* ‚îÄ‚îÄ Export Section ‚îÄ‚îÄ */
  .export-section {
    padding: 16px 20px;
  }

  .export-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .export-option:hover { border-color: var(--accent); background: var(--bg-elevated); }
  .export-option.disabled { opacity: 0.4; cursor: not-allowed; }

  .export-icon { font-size: 22px; }

  .export-details h4 {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 2px;
  }

  .export-details p {
    font-size: 11px;
    color: var(--text-muted);
  }

  /* ‚îÄ‚îÄ Corner Quick-Set ‚îÄ‚îÄ */
  .corner-quick-set {
    padding: 0 20px 14px;
  }

  .corner-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }

  .corner-field {
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .corner-field label {
    font-size: 10px;
    font-weight: 500;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .corner-field input {
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 5px;
    padding: 6px 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text-primary);
    width: 100%;
  }

  .corner-field input:focus { outline: none; border-color: var(--accent); }

  .corner-apply-row {
    margin-top: 10px;
    display: flex;
    justify-content: flex-end;
  }

  /* ‚îÄ‚îÄ Status bar ‚îÄ‚îÄ */
  .status-bar {
    padding: 10px 20px;
    background: var(--bg-tertiary);
    border-top: 1px solid var(--border);
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: var(--text-muted);
  }

  .status-dot.ready { background: var(--success); }
  .status-dot.warning { background: var(--warning); }

  /* ‚îÄ‚îÄ Toast ‚îÄ‚îÄ */
  .toast-container {
    position: fixed;
    top: 80px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .toast {
    padding: 12px 18px;
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    font-size: 13px;
    color: var(--text-primary);
    animation: toastIn 0.3s ease;
    max-width: 340px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  }

  .toast.success { border-left: 3px solid var(--success); }
  .toast.error { border-left: 3px solid var(--error); }
  .toast.info { border-left: 3px solid var(--info); }

  @keyframes toastIn {
    from { opacity: 0; transform: translateX(20px); }
    to { opacity: 1; transform: translateX(0); }
  }

  /* ‚îÄ‚îÄ Scrollbar ‚îÄ‚îÄ */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

  /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
  @media (max-width: 900px) {
    .app-layout {
      grid-template-columns: 1fr;
      grid-template-rows: 50vh 1fr;
    }
    .canvas-panel { border-right: none; border-bottom: 1px solid var(--border); }
  }

  /* ‚îÄ‚îÄ GCP marker on canvas ‚îÄ‚îÄ */
  .gcp-marker-tooltip {
    position: absolute;
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 3px 7px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-primary);
    pointer-events: none;
    white-space: nowrap;
    z-index: 30;
  }

  /* Modal */
  .modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 200;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
  }
  .modal-overlay.active { opacity: 1; pointer-events: all; }

  .modal {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 28px;
    max-width: 500px;
    width: 90%;
  }
  .modal h3 { font-size: 16px; margin-bottom: 14px; }
  .modal p { font-size: 13px; color: var(--text-secondary); line-height: 1.6; margin-bottom: 16px; }
  .modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
</style>
</head>
<body>

<header>
  <div class="logo">
    <div class="logo-icon">‚äï</div>
    <div>
      <h1>Geo<span>Ref</span></h1>
      <div class="logo-subtitle">Raster Georeferencing</div>
    </div>
  </div>
  <div class="header-actions">
    <button class="btn" id="btnReset" onclick="resetAll()" title="Start over">‚Ü∫ Reset</button>
    <button class="btn" id="btnHelp" onclick="toggleHelp()">? Help</button>
  </div>
</header>

<div class="app-layout">
  <!-- Canvas Panel -->
  <div class="canvas-panel" id="canvasPanel">
    <div class="upload-overlay" id="uploadOverlay">
      <div class="upload-zone" id="uploadZone">
        <div class="upload-icon">üó∫Ô∏è</div>
        <h3>Drop your raster image here</h3>
        <p>or click to browse files</p>
        <div class="formats">
          <span class="format-tag">JPG</span>
          <span class="format-tag">PNG</span>
          <span class="format-tag">TIFF</span>
          <span class="format-tag">BMP</span>
          <span class="format-tag">WebP</span>
        </div>
      </div>
      <input type="file" id="fileInput" accept="image/*,.tif,.tiff" hidden>
    </div>

    <div class="canvas-toolbar" id="canvasToolbar" style="display:none;">
      <button class="btn active" id="toolGcp" onclick="setTool('gcp')" title="Place GCP">üìç</button>
      <button class="btn" id="toolPan" onclick="setTool('pan')" title="Pan">‚úã</button>
      <button class="btn" onclick="zoomIn()" title="Zoom in">Ôºã</button>
      <button class="btn" onclick="zoomOut()" title="Zoom out">Ôºç</button>
      <button class="btn" onclick="zoomFit()" title="Fit to view">‚ä°</button>
    </div>

    <canvas id="imageCanvas"></canvas>

    <div class="canvas-info" id="canvasInfo" style="display:none;">
      <div><span>Pixel:</span> <strong id="infoPixel">‚Äî , ‚Äî</strong></div>
      <div><span>Zoom:</span> <strong id="infoZoom">100%</strong></div>
      <div><span>Image:</span> <strong id="infoSize">‚Äî √ó ‚Äî</strong></div>
    </div>
  </div>

  <!-- Side Panel -->
  <div class="side-panel">
    <div class="panel-tabs">
      <div class="panel-tab active" data-tab="gcps" onclick="switchTab('gcps')">GCPs</div>
      <div class="panel-tab" data-tab="settings" onclick="switchTab('settings')">Settings</div>
      <div class="panel-tab" data-tab="export" onclick="switchTab('export')">Export</div>
    </div>

    <div class="panel-content">
      <!-- GCPs Tab -->
      <div class="tab-page active" id="tabGcps">
        <div class="section-header">
          <h3>Ground Control Points</h3>
          <span style="font-size:12px;color:var(--text-muted)" id="gcpCount">0 points</span>
        </div>
        <div class="gcp-instructions">
          Click on the image to place a GCP marker, then enter the geographic coordinates (longitude, latitude) for each point. Minimum 3 GCPs required; 4+ recommended.
        </div>

        <!-- Quick corner bounds -->
        <div class="section-header">
          <h3>Quick Corner Bounds</h3>
        </div>
        <div class="gcp-instructions">
          If your map has known geographic extent, enter the bounding coordinates here and place 4 corner GCPs on the image. Then click "Apply Bounds" to auto-fill coordinates.
        </div>
        <div class="corner-quick-set">
          <div class="corner-grid">
            <div class="corner-field">
              <label>West Lon (¬∞E)</label>
              <input type="number" step="any" id="boundWest" placeholder="e.g. 96.00">
            </div>
            <div class="corner-field">
              <label>East Lon (¬∞E)</label>
              <input type="number" step="any" id="boundEast" placeholder="e.g. 96.25">
            </div>
            <div class="corner-field">
              <label>South Lat (¬∞N)</label>
              <input type="number" step="any" id="boundSouth" placeholder="e.g. 22.25">
            </div>
            <div class="corner-field">
              <label>North Lat (¬∞N)</label>
              <input type="number" step="any" id="boundNorth" placeholder="e.g. 22.50">
            </div>
          </div>
          <div class="corner-apply-row">
            <button class="btn btn-sm" onclick="applyCornerBounds()">Apply Bounds to 4 GCPs</button>
          </div>
        </div>

        <div class="section-header">
          <h3>GCP List</h3>
          <button class="btn btn-sm btn-danger" onclick="clearAllGcps()">Clear All</button>
        </div>
        <div class="gcp-list" id="gcpList">
          <div class="gcp-empty" id="gcpEmpty">
            <div class="icon">üìå</div>
            <div>No GCPs placed yet.<br>Click on the image to add points.</div>
          </div>
        </div>
      </div>

      <!-- Settings Tab -->
      <div class="tab-page" id="tabSettings">
        <div class="settings-section">
          <h4>Coordinate Reference System</h4>
          <div class="setting-row">
            <label>Output CRS</label>
            <select id="settingCrs">
              <option value="EPSG:4326">WGS 84 (EPSG:4326)</option>
              <option value="EPSG:32646">UTM 46N (EPSG:32646)</option>
              <option value="EPSG:32647">UTM 47N (EPSG:32647)</option>
              <option value="EPSG:32648">UTM 48N (EPSG:32648)</option>
            </select>
          </div>
        </div>

        <div class="settings-section">
          <h4>Coordinate Input Format</h4>
          <div class="setting-row">
            <label>Format</label>
            <select id="settingCoordFormat">
              <option value="dd">Decimal Degrees</option>
              <option value="dms">Degrees Minutes Seconds</option>
            </select>
          </div>
        </div>

        <div class="settings-section">
          <h4>Transform Method</h4>
          <div class="setting-row">
            <label>Method</label>
            <select id="settingTransform">
              <option value="affine">Affine (6-param)</option>
              <option value="polynomial1">1st Order Polynomial</option>
            </select>
          </div>
        </div>

        <div class="settings-section">
          <h4>GeoTIFF Compression</h4>
          <div class="setting-row">
            <label>Compression</label>
            <select id="settingCompression">
              <option value="none">None</option>
              <option value="lzw">LZW</option>
              <option value="deflate">Deflate</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Export Tab -->
      <div class="tab-page" id="tabExport">
        <div class="section-header">
          <h3>Export Georeferenced Data</h3>
        </div>
        <div class="gcp-instructions" id="exportStatus">
          Place at least 3 GCPs with coordinates to enable export.
        </div>

        <div class="export-section">
          <div class="export-option" id="exportGeotiff" onclick="exportGeoTIFF()">
            <div class="export-icon">üåç</div>
            <div class="export-details">
              <h4>GeoTIFF (.tif)</h4>
              <p>Full georeferenced raster with embedded CRS and transform</p>
            </div>
          </div>

          <div class="export-option" id="exportWorldFile" onclick="exportWorldFile()">
            <div class="export-icon">üìÑ</div>
            <div class="export-details">
              <h4>World File (.jgw / .pgw / .tfw)</h4>
              <p>Sidecar file with affine transform parameters</p>
            </div>
          </div>

          <div class="export-option" id="exportGcpFile" onclick="exportGcpFile()">
            <div class="export-icon">üìå</div>
            <div class="export-details">
              <h4>GCP File (.points)</h4>
              <p>QGIS-compatible ground control point file</p>
            </div>
          </div>

          <div class="export-option" id="exportGcpCsv" onclick="exportGcpCsv()">
            <div class="export-icon">üìä</div>
            <div class="export-details">
              <h4>GCP Table (.csv)</h4>
              <p>Spreadsheet-friendly GCP coordinate table</p>
            </div>
          </div>

          <div class="export-option" id="exportPrj" onclick="exportPrjFile()">
            <div class="export-icon">üîó</div>
            <div class="export-details">
              <h4>Projection File (.prj)</h4>
              <p>WKT projection definition file</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Upload an image to begin</span>
    </div>
  </div>
</div>

<!-- Toast container -->
<div class="toast-container" id="toastContainer"></div>

<!-- Help modal -->
<div class="modal-overlay" id="helpModal">
  <div class="modal">
    <h3>How to use GeoRef</h3>
    <p>
      <strong>1.</strong> Upload a raster image (scanned topographic map, aerial photo, etc.).<br><br>
      <strong>2.</strong> Click on known locations in the image to place Ground Control Points (GCPs).<br><br>
      <strong>3.</strong> Enter the geographic coordinates (longitude, latitude) for each GCP. Use the "Quick Corner Bounds" if you know the map extent.<br><br>
      <strong>4.</strong> Once you have 3+ GCPs with coordinates, go to the Export tab to download your georeferenced data.<br><br>
      <strong>Tips:</strong> Use 4 corner points for rectangular maps. More GCPs improve accuracy. The affine transform works well for most topographic maps.
    </p>
    <div class="modal-actions">
      <button class="btn btn-primary" onclick="toggleHelp()">Got it</button>
    </div>
  </div>
</div>

<script>
// ============================================================================
// STATE
// ============================================================================
const state = {
  image: null,       // HTMLImageElement
  imageData: null,   // ImageData from canvas for export
  fileName: '',
  gcps: [],          // [{id, pixelX, pixelY, lon, lat}]
  nextId: 1,
  tool: 'gcp',       // 'gcp' | 'pan'
  // Canvas transform
  scale: 1,
  offsetX: 0,
  offsetY: 0,
  isPanning: false,
  panStartX: 0,
  panStartY: 0,
  panOffsetX: 0,
  panOffsetY: 0,
};

const GCP_COLORS = [
  '#ff6b6b','#4ecdc4','#ffe66d','#a78bfa',
  '#f97316','#22d3ee','#34d399','#f472b6',
  '#818cf8','#fb923c','#2dd4bf','#fbbf24',
];

const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');

// ============================================================================
// FILE UPLOAD
// ============================================================================
const uploadZone = document.getElementById('uploadZone');
const fileInput = document.getElementById('fileInput');

uploadZone.addEventListener('click', () => fileInput.click());
uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('dragover'); });
uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
uploadZone.addEventListener('drop', e => {
  e.preventDefault();
  uploadZone.classList.remove('dragover');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', e => { if (e.target.files.length) handleFile(e.target.files[0]); });

// Also allow drop on the whole canvas panel
const canvasPanel = document.getElementById('canvasPanel');
canvasPanel.addEventListener('dragover', e => e.preventDefault());
canvasPanel.addEventListener('drop', e => {
  e.preventDefault();
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});

function handleFile(file) {
  state.fileName = file.name;
  const ext = file.name.split('.').pop().toLowerCase();

  // For TIFF files, try to handle via geotiff.js
  if (ext === 'tif' || ext === 'tiff') {
    handleTiffFile(file);
    return;
  }

  const reader = new FileReader();
  reader.onload = e => {
    const img = new Image();
    img.onload = () => {
      state.image = img;
      initCanvas();
      showToast('Image loaded: ' + file.name, 'success');
      updateStatus('ready', `Image loaded (${img.width}√ó${img.height})`);
    };
    img.onerror = () => showToast('Failed to load image', 'error');
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

async function handleTiffFile(file) {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
    const image = await tiff.getImage();
    const width = image.getWidth();
    const height = image.getHeight();
    const data = await image.readRasters();

    // Create canvas to render TIFF
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempCtx = tempCanvas.getContext('2d');
    const imageData = tempCtx.createImageData(width, height);

    const numBands = data.length;
    for (let i = 0; i < width * height; i++) {
      if (numBands >= 3) {
        imageData.data[i * 4] = data[0][i];
        imageData.data[i * 4 + 1] = data[1][i];
        imageData.data[i * 4 + 2] = data[2][i];
        imageData.data[i * 4 + 3] = numBands >= 4 ? data[3][i] : 255;
      } else {
        imageData.data[i * 4] = data[0][i];
        imageData.data[i * 4 + 1] = data[0][i];
        imageData.data[i * 4 + 2] = data[0][i];
        imageData.data[i * 4 + 3] = 255;
      }
    }
    tempCtx.putImageData(imageData, 0, 0);

    const img = new Image();
    img.onload = () => {
      state.image = img;
      initCanvas();
      showToast('TIFF loaded: ' + file.name, 'success');
      updateStatus('ready', `TIFF loaded (${width}√ó${height})`);
    };
    img.src = tempCanvas.toDataURL();
  } catch (err) {
    showToast('Failed to load TIFF: ' + err.message, 'error');
  }
}

// ============================================================================
// CANVAS
// ============================================================================
function initCanvas() {
  document.getElementById('uploadOverlay').classList.add('hidden');
  document.getElementById('canvasToolbar').style.display = 'flex';
  document.getElementById('canvasInfo').style.display = 'flex';
  document.getElementById('infoSize').textContent = `${state.image.width} √ó ${state.image.height}`;
  zoomFit();
}

function resizeCanvas() {
  const rect = canvasPanel.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  render();
}

window.addEventListener('resize', () => { if (state.image) resizeCanvas(); });

function zoomFit() {
  const rect = canvasPanel.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;

  const scaleX = canvas.width / state.image.width;
  const scaleY = canvas.height / state.image.height;
  state.scale = Math.min(scaleX, scaleY) * 0.92;
  state.offsetX = (canvas.width - state.image.width * state.scale) / 2;
  state.offsetY = (canvas.height - state.image.height * state.scale) / 2;
  render();
}

function zoomIn() { state.scale *= 1.25; render(); }
function zoomOut() { state.scale /= 1.25; render(); }

function render() {
  if (!state.image) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw checkerboard background
  ctx.fillStyle = '#1a1d26';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(state.offsetX, state.offsetY);
  ctx.scale(state.scale, state.scale);

  // Draw image
  ctx.drawImage(state.image, 0, 0);
  ctx.restore();

  // Draw GCP markers
  state.gcps.forEach((gcp, i) => {
    const sx = gcp.pixelX * state.scale + state.offsetX;
    const sy = gcp.pixelY * state.scale + state.offsetY;
    const color = GCP_COLORS[i % GCP_COLORS.length];

    // Crosshair
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx - 12, sy); ctx.lineTo(sx + 12, sy);
    ctx.moveTo(sx, sy - 12); ctx.lineTo(sx, sy + 12);
    ctx.stroke();

    // Circle
    ctx.beginPath();
    ctx.arc(sx, sy, 8, 0, Math.PI * 2);
    ctx.stroke();

    // Label
    ctx.fillStyle = color;
    ctx.font = 'bold 11px "JetBrains Mono", monospace';
    ctx.fillText(`GCP ${gcp.id}`, sx + 14, sy - 6);
  });

  document.getElementById('infoZoom').textContent = Math.round(state.scale * 100) + '%';
}

// Canvas mouse events
canvas.addEventListener('mousedown', e => {
  if (state.tool === 'pan' || e.button === 1) {
    state.isPanning = true;
    state.panStartX = e.clientX;
    state.panStartY = e.clientY;
    state.panOffsetX = state.offsetX;
    state.panOffsetY = state.offsetY;
    canvas.style.cursor = 'grabbing';
    e.preventDefault();
  } else if (state.tool === 'gcp' && e.button === 0 && state.image) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const px = (cx - state.offsetX) / state.scale;
    const py = (cy - state.offsetY) / state.scale;

    if (px >= 0 && px <= state.image.width && py >= 0 && py <= state.image.height) {
      addGcp(Math.round(px), Math.round(py));
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (state.isPanning) {
    state.offsetX = state.panOffsetX + (e.clientX - state.panStartX);
    state.offsetY = state.panOffsetY + (e.clientY - state.panStartY);
    render();
    return;
  }

  if (state.image) {
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const px = Math.round((cx - state.offsetX) / state.scale);
    const py = Math.round((cy - state.offsetY) / state.scale);
    document.getElementById('infoPixel').textContent =
      (px >= 0 && px <= state.image.width && py >= 0 && py <= state.image.height)
        ? `${px} , ${py}` : '‚Äî , ‚Äî';
  }
});

canvas.addEventListener('mouseup', () => {
  state.isPanning = false;
  canvas.style.cursor = state.tool === 'pan' ? 'grab' : 'crosshair';
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
  const newScale = state.scale * factor;

  state.offsetX = mx - (mx - state.offsetX) * (newScale / state.scale);
  state.offsetY = my - (my - state.offsetY) * (newScale / state.scale);
  state.scale = newScale;
  render();
}, { passive: false });

// ============================================================================
// TOOLS
// ============================================================================
function setTool(tool) {
  state.tool = tool;
  document.getElementById('toolGcp').classList.toggle('active', tool === 'gcp');
  document.getElementById('toolPan').classList.toggle('active', tool === 'pan');
  canvas.style.cursor = tool === 'pan' ? 'grab' : 'crosshair';
}

// ============================================================================
// GCPs
// ============================================================================
function addGcp(px, py) {
  const gcp = {
    id: state.nextId++,
    pixelX: px,
    pixelY: py,
    lon: null,
    lat: null,
  };
  state.gcps.push(gcp);
  renderGcpList();
  render();
  updateGcpStatus();
  showToast(`GCP ${gcp.id} placed at pixel (${px}, ${py})`, 'info');
}

function removeGcp(id) {
  state.gcps = state.gcps.filter(g => g.id !== id);
  renderGcpList();
  render();
  updateGcpStatus();
}

function clearAllGcps() {
  state.gcps = [];
  state.nextId = 1;
  renderGcpList();
  render();
  updateGcpStatus();
}

function updateGcpCoord(id, field, value) {
  const gcp = state.gcps.find(g => g.id === id);
  if (gcp) {
    gcp[field] = value === '' ? null : parseFloat(value);
    renderGcpList();
    updateGcpStatus();
  }
}

function renderGcpList() {
  const container = document.getElementById('gcpList');
  const empty = document.getElementById('gcpEmpty');

  if (state.gcps.length === 0) {
    container.innerHTML = '';
    container.appendChild(createEmptyElement());
    document.getElementById('gcpCount').textContent = '0 points';
    return;
  }

  document.getElementById('gcpCount').textContent = `${state.gcps.length} point${state.gcps.length > 1 ? 's' : ''}`;

  container.innerHTML = state.gcps.map((gcp, i) => {
    const color = GCP_COLORS[i % GCP_COLORS.length];
    const complete = gcp.lon !== null && gcp.lat !== null && !isNaN(gcp.lon) && !isNaN(gcp.lat);
    return `
      <div class="gcp-card ${complete ? 'complete' : 'incomplete'}">
        <div class="gcp-card-header">
          <div class="gcp-label">
            <div class="gcp-dot" style="background:${color}"></div>
            GCP ${gcp.id}
          </div>
          <button class="btn btn-sm btn-danger" onclick="removeGcp(${gcp.id})">‚úï</button>
        </div>
        <div class="gcp-card-body">
          <div class="gcp-field">
            <label>Pixel X</label>
            <input type="text" value="${gcp.pixelX}" readonly>
          </div>
          <div class="gcp-field">
            <label>Pixel Y</label>
            <input type="text" value="${gcp.pixelY}" readonly>
          </div>
          <div class="gcp-field">
            <label>Longitude (¬∞E)</label>
            <input type="number" step="any" value="${gcp.lon !== null ? gcp.lon : ''}"
              placeholder="e.g. 96.125"
              onchange="updateGcpCoord(${gcp.id},'lon',this.value)">
          </div>
          <div class="gcp-field">
            <label>Latitude (¬∞N)</label>
            <input type="number" step="any" value="${gcp.lat !== null ? gcp.lat : ''}"
              placeholder="e.g. 22.375"
              onchange="updateGcpCoord(${gcp.id},'lat',this.value)">
          </div>
        </div>
      </div>`;
  }).join('');
}

function createEmptyElement() {
  const div = document.createElement('div');
  div.className = 'gcp-empty';
  div.innerHTML = '<div class="icon">üìå</div><div>No GCPs placed yet.<br>Click on the image to add points.</div>';
  return div;
}

function updateGcpStatus() {
  const complete = state.gcps.filter(g => g.lon !== null && g.lat !== null && !isNaN(g.lon) && !isNaN(g.lat));
  const n = complete.length;

  if (n >= 3) {
    updateStatus('ready', `${n} GCPs ready ‚Äî export available`);
    document.getElementById('exportStatus').textContent = `‚úì ${n} GCPs with coordinates. Ready to export.`;
  } else {
    updateStatus('warning', `${n}/3 GCPs with coordinates`);
    document.getElementById('exportStatus').textContent = `Need ${3 - n} more GCP${3 - n > 1 ? 's' : ''} with coordinates to enable export.`;
  }
}

// ============================================================================
// CORNER BOUNDS (Quick-Set)
// ============================================================================
function applyCornerBounds() {
  const w = parseFloat(document.getElementById('boundWest').value);
  const e_ = parseFloat(document.getElementById('boundEast').value);
  const s = parseFloat(document.getElementById('boundSouth').value);
  const n = parseFloat(document.getElementById('boundNorth').value);

  if ([w, e_, s, n].some(isNaN)) {
    showToast('Please fill in all 4 bounding coordinates', 'error');
    return;
  }

  if (state.gcps.length < 4) {
    showToast('Place exactly 4 GCPs on the image corners first', 'error');
    return;
  }

  // Sort GCPs by position: top-left, top-right, bottom-left, bottom-right
  const sorted = [...state.gcps.slice(0, 4)];
  sorted.sort((a, b) => a.pixelY - b.pixelY); // sort by Y first

  const topTwo = sorted.slice(0, 2).sort((a, b) => a.pixelX - b.pixelX);
  const bottomTwo = sorted.slice(2, 4).sort((a, b) => a.pixelX - b.pixelX);

  // NW (top-left): West, North
  topTwo[0].lon = w;
  topTwo[0].lat = n;
  // NE (top-right): East, North
  topTwo[1].lon = e_;
  topTwo[1].lat = n;
  // SW (bottom-left): West, South
  bottomTwo[0].lon = w;
  bottomTwo[0].lat = s;
  // SE (bottom-right): East, South
  bottomTwo[1].lon = e_;
  bottomTwo[1].lat = s;

  renderGcpList();
  updateGcpStatus();
  showToast('Corner coordinates applied to first 4 GCPs', 'success');
}

// ============================================================================
// AFFINE TRANSFORM
// ============================================================================
function computeAffineTransform() {
  const gcps = state.gcps.filter(g => g.lon !== null && g.lat !== null && !isNaN(g.lon) && !isNaN(g.lat));

  if (gcps.length < 3) return null;

  // Solve for affine parameters using least squares
  // lon = a*col + b*row + c
  // lat = d*col + e*row + f
  const n = gcps.length;
  const A = [];
  const bx = [];
  const by = [];

  for (const gcp of gcps) {
    A.push([gcp.pixelX, gcp.pixelY, 1]);
    bx.push(gcp.lon);
    by.push(gcp.lat);
  }

  const paramsX = leastSquares(A, bx);
  const paramsY = leastSquares(A, by);

  if (!paramsX || !paramsY) return null;

  // GeoTIFF affine: [a, b, c, d, e, f]
  // x_geo = a * col + b * row + c
  // y_geo = d * col + e * row + f
  return {
    a: paramsX[0], b: paramsX[1], c: paramsX[2],
    d: paramsY[0], e: paramsY[1], f: paramsY[2],
  };
}

function leastSquares(A, b) {
  // Normal equations: (A^T A) x = A^T b
  const n = A.length;
  const m = A[0].length;

  // A^T A
  const ATA = Array.from({length: m}, () => new Float64Array(m));
  for (let i = 0; i < m; i++)
    for (let j = 0; j < m; j++)
      for (let k = 0; k < n; k++)
        ATA[i][j] += A[k][i] * A[k][j];

  // A^T b
  const ATb = new Float64Array(m);
  for (let i = 0; i < m; i++)
    for (let k = 0; k < n; k++)
      ATb[i] += A[k][i] * b[k];

  // Solve 3x3 system using Gaussian elimination
  const mat = ATA.map((row, i) => [...row, ATb[i]]);
  return gaussianElimination(mat);
}

function gaussianElimination(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    // Partial pivoting
    let maxVal = Math.abs(mat[i][i]);
    let maxRow = i;
    for (let k = i + 1; k < n; k++) {
      if (Math.abs(mat[k][i]) > maxVal) {
        maxVal = Math.abs(mat[k][i]);
        maxRow = k;
      }
    }
    [mat[i], mat[maxRow]] = [mat[maxRow], mat[i]];

    if (Math.abs(mat[i][i]) < 1e-12) return null;

    for (let k = i + 1; k < n; k++) {
      const factor = mat[k][i] / mat[i][i];
      for (let j = i; j <= n; j++) mat[k][j] -= factor * mat[i][j];
    }
  }

  const x = new Float64Array(n);
  for (let i = n - 1; i >= 0; i--) {
    x[i] = mat[i][n];
    for (let j = i + 1; j < n; j++) x[i] -= mat[i][j] * x[j];
    x[i] /= mat[i][i];
  }
  return x;
}

// ============================================================================
// EXPORT: GeoTIFF
// ============================================================================
async function exportGeoTIFF() {
  const transform = computeAffineTransform();
  if (!transform) {
    showToast('Need at least 3 GCPs with coordinates', 'error');
    return;
  }

  showToast('Generating GeoTIFF... this may take a moment', 'info');

  try {
    // Draw image to a temp canvas to get pixel data
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = state.image.width;
    tempCanvas.height = state.image.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(state.image, 0, 0);
    const imageData = tempCtx.getImageData(0, 0, state.image.width, state.image.height);
    const pixels = imageData.data;

    const w = state.image.width;
    const h = state.image.height;

    // Separate into bands
    const red = new Uint8Array(w * h);
    const green = new Uint8Array(w * h);
    const blue = new Uint8Array(w * h);

    for (let i = 0; i < w * h; i++) {
      red[i] = pixels[i * 4];
      green[i] = pixels[i * 4 + 1];
      blue[i] = pixels[i * 4 + 2];
    }

    // Build GeoTIFF using geotiff.js writeArrayBuffer
    const metadata = {
      width: w,
      height: h,
      ModelTiepoint: [0, 0, 0, transform.c, transform.f, 0],
      ModelPixelScale: [transform.a, -transform.e, 0],
      PhotometricInterpretation: 2, // RGB
      GeographicTypeGeoKey: 4326,
      ProjectedCSTypeGeoKey: 32767,
    };

    const arrayBuffer = await GeoTIFF.writeArrayBuffer(
      [red, green, blue],
      metadata
    );

    downloadBlob(new Blob([arrayBuffer], {type: 'image/tiff'}), getOutputName('.tif'));
    showToast('GeoTIFF exported successfully!', 'success');

  } catch (err) {
    console.error('GeoTIFF export error:', err);
    // Fallback: export as world file + original image
    showToast('GeoTIFF generation failed. Try exporting a World File instead. Error: ' + err.message, 'error');
  }
}

// ============================================================================
// EXPORT: World File
// ============================================================================
function exportWorldFile() {
  const transform = computeAffineTransform();
  if (!transform) {
    showToast('Need at least 3 GCPs with coordinates', 'error');
    return;
  }

  // World file format (6 lines):
  // Line 1: pixel size in x (a)
  // Line 2: rotation about y axis (d)
  // Line 3: rotation about x axis (b)
  // Line 4: pixel size in y (e) ‚Äî negative for north-up
  // Line 5: x coordinate of center of upper-left pixel
  // Line 6: y coordinate of center of upper-left pixel
  const centerX = transform.a * 0.5 + transform.b * 0.5 + transform.c;
  const centerY = transform.d * 0.5 + transform.e * 0.5 + transform.f;

  const content = [
    transform.a.toFixed(12),
    transform.d.toFixed(12),
    transform.b.toFixed(12),
    transform.e.toFixed(12),
    centerX.toFixed(12),
    centerY.toFixed(12),
  ].join('\n');

  // Determine extension based on input format
  const ext = state.fileName.split('.').pop().toLowerCase();
  const worldExts = { jpg: 'jgw', jpeg: 'jgw', png: 'pgw', tif: 'tfw', tiff: 'tfw', bmp: 'bpw' };
  const worldExt = worldExts[ext] || 'wld';

  downloadBlob(new Blob([content], {type: 'text/plain'}), getOutputName('.' + worldExt));
  showToast(`World file (.${worldExt}) exported!`, 'success');
}

// ============================================================================
// EXPORT: GCP File (QGIS format)
// ============================================================================
function exportGcpFile() {
  const gcps = state.gcps.filter(g => g.lon !== null && g.lat !== null);
  if (gcps.length < 3) {
    showToast('Need at least 3 GCPs with coordinates', 'error');
    return;
  }

  const crs = document.getElementById('settingCrs').value;
  let content = `#CRS: ${crs}\nmapX,mapY,sourceX,sourceY,enable,dX,dY,residual\n`;

  gcps.forEach(gcp => {
    content += `${gcp.lon},${gcp.lat},${gcp.pixelX},${gcp.pixelY},1,0,0,0\n`;
  });

  downloadBlob(new Blob([content], {type: 'text/plain'}), getOutputName('.points'));
  showToast('GCP file (.points) exported for QGIS!', 'success');
}

// ============================================================================
// EXPORT: CSV
// ============================================================================
function exportGcpCsv() {
  const gcps = state.gcps.filter(g => g.lon !== null && g.lat !== null);
  if (gcps.length === 0) {
    showToast('No GCPs with coordinates to export', 'error');
    return;
  }

  let content = 'GCP_ID,Pixel_X,Pixel_Y,Longitude,Latitude\n';
  gcps.forEach(gcp => {
    content += `${gcp.id},${gcp.pixelX},${gcp.pixelY},${gcp.lon},${gcp.lat}\n`;
  });

  downloadBlob(new Blob([content], {type: 'text/csv'}), getOutputName('_gcps.csv'));
  showToast('GCP table (.csv) exported!', 'success');
}

// ============================================================================
// EXPORT: PRJ File
// ============================================================================
function exportPrjFile() {
  const crs = document.getElementById('settingCrs').value;
  const wktMap = {
    'EPSG:4326': 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
    'EPSG:32646': 'PROJCS["WGS_1984_UTM_Zone_46N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",93.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
    'EPSG:32647': 'PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
    'EPSG:32648': 'PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",105.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  };

  const wkt = wktMap[crs] || wktMap['EPSG:4326'];
  downloadBlob(new Blob([wkt], {type: 'text/plain'}), getOutputName('.prj'));
  showToast('Projection file (.prj) exported!', 'success');
}

// ============================================================================
// UI HELPERS
// ============================================================================
function getOutputName(ext) {
  const base = state.fileName.replace(/\.[^.]+$/, '') || 'georef';
  return base + '_georef' + ext;
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function switchTab(tab) {
  document.querySelectorAll('.panel-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  document.querySelectorAll('.tab-page').forEach(p => p.classList.remove('active'));
  document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active');
}

function updateStatus(type, text) {
  document.getElementById('statusDot').className = 'status-dot ' + type;
  document.getElementById('statusText').textContent = text;
}

function showToast(message, type = 'info') {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.textContent = message;
  container.appendChild(toast);
  setTimeout(() => toast.remove(), 4000);
}

function toggleHelp() {
  document.getElementById('helpModal').classList.toggle('active');
}

function resetAll() {
  state.image = null;
  state.gcps = [];
  state.nextId = 1;
  state.fileName = '';
  state.scale = 1;
  state.offsetX = 0;
  state.offsetY = 0;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  document.getElementById('uploadOverlay').classList.remove('hidden');
  document.getElementById('canvasToolbar').style.display = 'none';
  document.getElementById('canvasInfo').style.display = 'none';
  renderGcpList();
  updateStatus('', 'Upload an image to begin');
  switchTab('gcps');
  fileInput.value = '';
}

// Init
renderGcpList();
</script>
</body>
</html>
